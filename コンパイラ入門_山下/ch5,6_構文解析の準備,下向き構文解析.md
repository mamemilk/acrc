# 5章 構文解析

## 章のまとめ

- 文脈自由文法<br>
  各構文規則により終端記号になるまで分解する。
```
Program   -> DeclStmts PrintStmts
DeclStmts -> DeclStmt SEMI
DeclStmts -> DeclStmt SEMI DeclStmts
```
Gの定義する文脈自由語(context-free language) L(G)。<br>
ここにL(G)の定義がくる。

Gにおいて、任意の非終端記号Xについて、Xを含む文形式が少なくとも1つ存在し、かつXから少なくとも1つの終端記号列を導出できるなら、Gは簡約系(reduced form)という。


- 最左導出(leftmost derivation)
- 構文木と曖昧性
- 拡大文法とEoFトークン

## 問題1

```
1: Program -> Inputs Outputs
2: Inputs  -> Input
3: Inputs  -> Inputs Input
4: Outputs -> ε
5: Outputs -> Outputs Output
6: Input   -> INPUT VAR
7: Output  -> OUTPUT Exp
8: Exp     -> VAR
9: Exp     -> Exp PLUS VAR

"input"           {return INPUT;}
"output"          {return OUTPUT;}
"+"               {return PLUS;}
[a-zA-Z]          {return VAR;}
[" "|"\n"|"\t"]+  {}
.                 {return ERROR;}
```

変数はアルファベット1文字。

```
(a) input X input Y output X+Y      : OK
(b) input X, Y;   output X+Y        : NG  Inputs Input(=INPUT VAR)なのでいきなりカンマはNG, セミコロンもNG
(c) input A1 input A2 output A1+A2  : NG  [a-zA-Z] {return VAR;}なので、VARに変数入らない
(d) input a input a                 : OK  Outputsは、ε(空集合)あり。
(e) INPUT X OUTPUT X                : NG  VAR VAR VAR VARで、適合する文法なし
(f) input a output a+10             : NG  10をVARとしたいが、VARはアルファベットのみ。。。    
(g) input a output b+c+d            : OK  OUTPUT Exp(=Exp PLUS VAR)
```

## 問題2

```
1: A -> NUM
2: A -> B C
3: B -> ID
4: C -> C ID
5: D -> NUM
6: D -> B D
```
NUM, IDが終端記号

(1)

簡約系
- Dを右辺に含むD以外の構文規則がないため、終端記号に分解できない。
- C -> IDがないと、終端記号列が導出できない。


簡約系とは 
```
任意(全て,any)の非終端記号Xについて、Xを含む文形式が少なくとも1つ存在し、かつXから少なくとも1つの終端記号列を導出できるなら、Gは簡約系(reduced form)という。
```
-> 終端記号のみに変換できる上に全ての非終端文字が"登場"できる、という理解でよいかな？？

Aが開始記号だとすると(開始器記号 : 一行目の構文規則の左辺の記号)、という記述の意図に悩んだが、Aを開始記号だとするとDが分解できない、Dを開始記号にすると、CとAが分解できない、というのでよい？？？

不要な構文規則を排除する。非終端記号Cを削除。A -> B Dと変更

```
1: A -> NUM
2: A -> B D
3: B -> ID
4: D -> NUM
5: D -> B D
```

NUM <br>
ID NUM <br>
ID ID NUM <br>
ID ID ID NUM <br>
....(ID繰り返し)
が表現できる

鳥海さんの回答は以下にしてて、確かに題意を満たしてそう。
```
1: A -> NUM
```


(2)

Dを開始器記号とすると、

- AとCの非終端記号が導出されることがない。

不要な構文規則を削除すると。
```
1: D -> NUM
2: D -> B D
3: B -> ID
```

NUM <br>
ID NUM <br>
ID ID NUM <br>
ID ID ID NUM <br>
....(ID繰り返し)
が表現できるが表現できる。


(3)

a) 文法が簡約系になるかのテスト

開始記号から、とりうる非終端記号、終端記号をnodeにもつグラフを作る。
同じ非終端記号がnodeになったら、もしくは、終端記号に達したら、探索終了。
探索が終了しなかった(どうやって証明する？)、規則がグラフ上にでてこなかったら、簡約系ではない。

> 八木さん指摘 : 探索済みの枝は探索終了とする。


b) 簡約形にするアルゴリズム
- でてこない規約を取り除く。
- 終端しない規約にεを追加する。


## 問題3

図5.6の規則(四則演算を表す曖昧でない文法)
```
1: Exp    -> Exp ADD Term
2: Exp    -> Exp SUB Term 
3: Exp    -> Term
4: Term   -> Term MUL Factor
5: Term   -> Term DIV Factor
6: Term   -> Factor
7: Factor -> ID
8: Factor -> NUM
9: Factor -> LPAR Exp RPAR
```


```
  a+3*b
= (Exp    ) ADD (Term              )
= (Term   ) ADD (Term   MUL Factor )
= (Factor ) ADD (Factor MUL ID     )
= (ID     ) ADD (NUM MUL ID        )
```

を書き換えた場合にどうなる？
```
1: Exp    -> Term ADD Exp
2: Exp    -> Term SUB Exp 
3: Exp    -> Term
4: Term   -> Factor MUL Term
5: Term   -> Factor DIV Term
6: Term   -> Factor
7: Factor -> ID
8: Factor -> NUM
9: Factor -> LPAR Exp RPAR
```

```
  a+3*b
= (Term   ) ADD (Exp              )
= (Factor ) ADD (Term             )
= (ID     ) ADD (Factor MUL Term  )
= (ID     ) ADD (NUM    MUL ID    )
```

-> 演算子の優先順位は守られる。a+3*bだと、左結合性、右結合性はわからない。

1+2+3でやると、
前者は左結合的、後者は右結合的。

図5.6規則の場合
```
  1+2+3 
= Exp(1+2)            ADD Term(3)
= Exp ADD Term        ADD Term 
```

書き換え版の場合
```
  1+2+3 
= Term(1)             ADD Exp(2+3)
= Term                ADD (Term ADD Exp)
```

左結合的と、右結合的で減算の場合だと、答えが変わってしまう。

```
3 - 2 - 1   = 0
3 - (2 - 1) = 2  : 右結合的
(3 - 2) -1  = 0  : 左結合的
```

## 問題4

左結合的にしておいて、FactorのSUB NUMを追加する。
-> 普通の四則演算ができる。

右結合的にすると、四則演算にならない。

10を追加。
```
1: Exp    -> Exp ADD Term
2: Exp    -> Exp SUB Term 
3: Exp    -> Term
4: Term   -> Term MUL Factor
5: Term   -> Term DIV Factor
6: Term   -> Factor
7: Factor -> ID
8: Factor -> NUM
9: Factor -> LPAR Exp RPAR
10: Factor -> SUB NUM
```


# 6章 

First集合    : 非終端記号の最初にでうる終端記号の集合
Director集合 : 

## 問題1

[yylexを改造したソース](./chapt5,6/sl0.c)


1)

EX EoF 
! を渡すと、


|   関数呼び出しの残り | 入力記号の残り |
| -------------------: | -------------- |
|                 Z(); | EX EoF         |
|        Stmt();eOf(); | EX EoF         |
| eat(EX);Exp();eOf(); | EX EoF         |
|         Exp();eOf(); | EoF            |
|      eat(NUM);eOf(); | EoF            |
→ここでerror()


1) 

NUM NUM EoF
1 2 を渡すと、

|   関数呼び出しの残り | 入力記号の残り |
| -------------------: | :------------- |
|                 Z(); | NUM NUM EoF    |
|        Stmt();eOf(); | NUM NUM EoF    |
| eat(EX);Exp();eOf(); | NUM NUM EoF    |
→ここでerror()



## 問題2

図6.10の文法

```
0: Z -> A EoF
1: A -> SEMI
2: A -> B C
3: B -> ε
4: C -> B
5: C -> A NUM
```

Director集合

| 構文規則      | Director集合     |
| ------------- | ---------------- |
| 0: Z -> A EoF | {NUM, SEMI, EoF} |
| 1: A -> SEMI  | {SEMI}           |
| 2: A -> B C   | {NUM, SEMI, EoF} |
| 3: B -> ε     | {NUM, SEMI, EoF} |
| 4: C -> B     | {NUM, EoF}       |
| 5: C -> A NUM | {NUM, SEMI}      |

構文解析表
|     | NUM                  | SEMI                  | EoF        |
| --- | -------------------- | --------------------- | ---------- |
| Z   | Z -> A EoF           | Z -> A EoF            | Z -> A EoF |
| A   | A -> B C             | A -> SEMI<br>A -> B C | A -> B C   |
| B   | B -> ε               | B -> ε                | B -> ε     |
| C   | C -> B<br>C -> A NUM | C -> A NUM            | C -> B     |


