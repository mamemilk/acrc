# 5章 構文解析

## 章のまとめ

- 文脈自由文法<br>
  各構文規則により終端記号になるまで分解する。
```
Program   -> DeclStmts PrintStmts
DeclStmts -> DeclStmt SEMI
DeclStmts -> DeclStmt SEMI DeclStmts
```
Gの定義する文脈自由語(context-free language) L(G)。<br>
ここにL(G)の定義がくる。

Gにおいて、任意の非終端記号Xについて、Xを含む文形式が少なくとも1つ存在し、かつXから少なくとも1つの終端記号列を導出できるなら、Gは簡約系(reduced form)という。


- 最左導出(leftmost derivation)
- 構文木と曖昧性
- 拡大文法とEoFトークン

- 集合の説明
  
文中に集合で説明が入るが、肝としては、開始記号から開始し構文規則で導出(置き換え)して終端記号になるのが、文脈自由言語。

$$
  G : 文脈自由文法        \\
  T : 終端記号の有限集合   \\
  N : 非終端記号の有限集合  \\
  P : 構文規則の有限集合    \\
  S : 開始記号 (\in N)     \\
 \\

\alpha1 \Rightarrow \alpha2 : 導出\\

Gの定義する文脈自由語L(G)とは\\
  L(G) = \{ u \in T^\ast | S \Rightarrow ^\ast u \}  
$$


## 問題1

```
1: Program -> Inputs Outputs
2: Inputs  -> Input
3: Inputs  -> Inputs Input
4: Outputs -> ε
5: Outputs -> Outputs Output
6: Input   -> INPUT VAR
7: Output  -> OUTPUT Exp
8: Exp     -> VAR
9: Exp     -> Exp PLUS VAR

"input"           {return INPUT;}
"output"          {return OUTPUT;}
"+"               {return PLUS;}
[a-zA-Z]          {return VAR;}
[" "|"\n"|"\t"]+  {}
.                 {return ERROR;}
```

変数はアルファベット1文字。

```
(a) input X input Y output X+Y      : OK
(b) input X, Y;   output X+Y        : NG  Inputs Input(=INPUT VAR)なのでいきなりカンマはNG, セミコロンもNG
(c) input A1 input A2 output A1+A2  : NG  [a-zA-Z] {return VAR;}なので、VARに変数入らない
(d) input a input a                 : OK  Outputsは、ε(空集合)あり。
(e) INPUT X OUTPUT X                : NG  VAR VAR VAR VARで、適合する文法なし
(f) input a output a+10             : NG  10をVARとしたいが、VARはアルファベットのみ。。。    
(g) input a output b+c+d            : OK  OUTPUT Exp(=Exp PLUS VAR)
```

## 問題2

```
1: A -> NUM
2: A -> B C
3: B -> ID
4: C -> C ID
5: D -> NUM
6: D -> B D
```
NUM, IDが終端記号

(1)

簡約系
- Dを右辺に含むD以外の構文規則がないため、終端記号に分解できない。
- C -> IDがないと、終端記号列が導出できない。


簡約系とは 
```
任意(全て,any)の非終端記号Xについて、Xを含む文形式が少なくとも1つ存在し、かつXから少なくとも1つの終端記号列を導出できるなら、Gは簡約系(reduced form)という。
```
-> 終端記号のみに変換できる上に全ての非終端文字が"登場"できる、という理解でよいかな？？

Aが開始記号だとすると(開始器記号 : 一行目の構文規則の左辺の記号)、という記述の意図に悩んだが、Aを開始記号だとするとDが分解できない、Dを開始記号にすると、CとAが分解できない、というのでよい？？？

不要な構文規則を排除する。非終端記号Cを削除。A -> B Dと変更

```
1: A -> NUM
2: A -> B D
3: B -> ID
4: D -> NUM
5: D -> B D
```

NUM <br>
ID NUM <br>
ID ID NUM <br>
ID ID ID NUM <br>
....(ID繰り返し)
が表現できる

鳥海さんの回答は以下にしてて、確かに題意を満たしてそう。
```
1: A -> NUM
```


(2)

Dを開始器記号とすると、

- AとCの非終端記号が導出されることがない。

不要な構文規則を削除すると。
```
1: D -> NUM
2: D -> B D
3: B -> ID
```

NUM <br>
ID NUM <br>
ID ID NUM <br>
ID ID ID NUM <br>
....(ID繰り返し)
が表現できるが表現できる。


(3)

a) 文法が簡約系になるかのテスト

開始記号から、とりうる非終端記号、終端記号をnodeにもつグラフを作る。
同じ非終端記号がnodeになったら、もしくは、終端記号に達したら、探索終了。
探索が終了しなかった(どうやって証明する？)、規則がグラフ上にでてこなかったら、簡約系ではない。

> 八木さん指摘 : 探索済みの枝は探索終了とする。


b) 簡約形にするアルゴリズム
- でてこない規約を取り除く。
- 終端しない規約にεを追加する。


## 問題3

図5.6の規則(四則演算を表す曖昧でない文法)
```
1: Exp    -> Exp ADD Term
2: Exp    -> Exp SUB Term 
3: Exp    -> Term
4: Term   -> Term MUL Factor
5: Term   -> Term DIV Factor
6: Term   -> Factor
7: Factor -> ID
8: Factor -> NUM
9: Factor -> LPAR Exp RPAR
```


```
  a+3*b
= (Exp    ) ADD (Term              )
= (Term   ) ADD (Term   MUL Factor )
= (Factor ) ADD (Factor MUL ID     )
= (ID     ) ADD (NUM MUL ID        )
```

を書き換えた場合にどうなる？
```
1: Exp    -> Term ADD Exp
2: Exp    -> Term SUB Exp 
3: Exp    -> Term
4: Term   -> Factor MUL Term
5: Term   -> Factor DIV Term
6: Term   -> Factor
7: Factor -> ID
8: Factor -> NUM
9: Factor -> LPAR Exp RPAR
```

```
  a+3*b
= (Term   ) ADD (Exp              )
= (Factor ) ADD (Term             )
= (ID     ) ADD (Factor MUL Term  )
= (ID     ) ADD (NUM    MUL ID    )
```

-> 演算子の優先順位は守られる。a+3*bだと、左結合性、右結合性はわからない。

1+2+3でやると、
前者は左結合的、後者は右結合的。

図5.6規則の場合
```
  1+2+3 
= Exp(1+2)            ADD Term(3)
= Exp ADD Term        ADD Term 
```

書き換え版の場合
```
  1+2+3 
= Term(1)             ADD Exp(2+3)
= Term                ADD (Term ADD Exp)
```

左結合的と、右結合的で減算の場合だと、答えが変わってしまう。

```
3 - 2 - 1   = 0
3 - (2 - 1) = 2  : 右結合的
(3 - 2) -1  = 0  : 左結合的
```

## 問題4

左結合的にしておいて、FactorのSUB NUMを追加する。
-> 普通の四則演算ができる。

右結合的にすると、四則演算にならない。

10を追加。
```
1: Exp    -> Exp ADD Term
2: Exp    -> Exp SUB Term 
3: Exp    -> Term
4: Term   -> Term MUL Factor
5: Term   -> Term DIV Factor
6: Term   -> Factor
7: Factor -> ID
8: Factor -> NUM
9: Factor -> LPAR Exp RPAR
10: Factor -> SUB NUM
```


# 6章 

## 本文まとめ
### 空列ない場合
- Director集合 : 

$$
X \Rightarrow \alpha のDirector集合とは、\\
X \Rightarrow \alphaの構文規則を導出していったときにでてくる最左の終端記号の集合
$$

- First集合 :

$$
X \Rightarrow \alpha における\alpha のFirst集合とは、\\
非終端記号の導出したときに、最左にでうる終端記号の集合。
$$

右辺が空列であることを許容しない場合、以下は一致する。
$$
First(\alpha) = Director(X \rightarrow \alpha)
$$


### 空列ある場合

空列があると、DirectorとFirst集合は一致しない。
$$
X \rightarrow \alphaで、\alphaがεだったら、Director(X \rightarrow \alpha)は、次の非終端記号のDirector集合になる。
$$

Xの次にくる終端記号をFollow集合とする。

$$
nullable(\alpha)のとき \\
Director(X \rightarrow \alpha) = First(\alpha) \cup Follow(X) 
$$


### LL文法

- 下向き構文解析法で、解析可能な文法をLL()文法とよぶ
- 下向き構文解析法は、Left to rigth, Leftmost derivationの最左導出
- 何語、先読みするかで、LL(1)もしくはLL(k)とする。

### 文法変換

LL(1)に変換する手法
- 左再帰除去法
  左再帰はLL(1)ではない。εにもなる新しい非終端記号を導入する
- 左括り出し
  IF, IF ELSEは同じDirector集合になる。共通部分を括り出す。


## 問題1

[yylexを改造したソース](./chapt5,6/sl0.c)


1) EX EoF<br> 
! を渡すと、

|   関数呼び出しの残り | 入力記号の残り |
| -------------------: | -------------- |
|                 Z(); | EX EoF         |
|        Stmt();eOf(); | EX EoF         |
| eat(EX);Exp();eOf(); | EX EoF         |
|         Exp();eOf(); | EoF            |
|      eat(NUM);eOf(); | EoF            |
→ここでerror()


2) NUM NUM EoF<br>
1 2 を渡すと、

|   関数呼び出しの残り | 入力記号の残り |
| -------------------: | :------------- |
|                 Z(); | NUM NUM EoF    |
|        Stmt();eOf(); | NUM NUM EoF    |
| eat(EX);Exp();eOf(); | NUM NUM EoF    |
→ここでerror()



## 問題2

3: B->εで、空規則を含む。
5: C-> A NUMで、再帰を含む。

構文規則を追っていくよりは、
- 表6.12からA,B,Cはnullable
- X->αで、αがnulabbleの場合は、Director(X->α) = First(α) U Follow(X)を使う方が確実


図6.10の文法
```
0: Z -> A EoF
1: A -> SEMI
2: A -> B C
3: B -> ε
4: C -> B
5: C -> A NUM
```


Director集合

| 構文規則      |                          | Director集合     |                                             |
| ------------- | ------------------------ | ---------------- | ------------------------------------------- |
| 0: Z -> A EoF | First(A EOF) U Follow(Z) | {NUM, SEMI, EoF} |                                             |
| 1: A -> SEMI  | First(SEMI)              | {SEMI}           |                                             |
| 2: A -> B C   | First(B C) U Follow(A)   | {NUM, SEMI, EoF} | First(B C) = First(B) U First(C)            |
| 3: B -> ε     | First(ε)                 | {NUM, SEMI, EoF} | Bの後にCがくる。CのDirector集合が追加される |
| 4: C -> B     | First(B) U Follow(C)     | {NUM, EoF}       |
| 5: C -> A NUM | First(A NUM)             | {NUM, SEMI}      | A NUMはnullableではない

構文解析表
|     | NUM                  | SEMI                  | EoF        |
| --- | -------------------- | --------------------- | ---------- |
| Z   | Z -> A EoF           | Z -> A EoF            | Z -> A EoF |
| A   | A -> B C             | A -> SEMI<br>A -> B C | A -> B C   |
| B   | B -> ε               | B -> ε                | B -> ε     |
| C   | C -> B<br>C -> A NUM | C -> A NUM            | C -> B     |

上記の表で変観則が2つ以上あるものは衝突しているので、下向き解析できない。

## 問題3

```
0: Z      -> tt Exp EoF
1: Exp    -> Term Exp2
2: Exp2   -> ADD Term Exp2
3: Exp2   -> SUB Term Exp2
4: Exp2   -> ε
5: Term   -> Factor Term2
6: Term2  -> MUL Factor Term2
7: Term2  -> DIV Factor Term2
8: Term2  -> ε
9: Factor -> ID
10: Factor -> NUM
11: Factor -> LPAR Exp RPAR
```



