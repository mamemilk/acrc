# 5章：原始帰納的関数

## 5.1

かけ算が、原始帰納的であることを示す。

```
# 足し算の場合
f(x,y) = x + y
-> 
f(x,0) = x,
f(x,y+1) = suc(f(x,y))


# かけ算の場合 
f(x,y) = x * y
-> 
f(x,0) = 0
f(x,y+1) = f(x,y) + x

足し算が原始帰納的なことは上記で示されているため、上記により、かけ算も原始帰納的であることが示される。
```

## 5.2 

1変数関数gが原始帰納的ならば、f(x,y) = g^y (x) = g(g(g(...)))も原始帰納的であることを示す。

```
f(x,0) = 1
f(x,y+1) = g(f(x,y))
```

## 5.3 

(a)
それぞれ以下のように関数プログラムの記載が可能なため、while文を使用しない関数プログラムが存在することが証明される。

- zero
  ```
  zero(){
    return(0);
  }
  ```

- suc
  ```
  suc(v1){
    v1++;
    return(v1);
  }
  ```

- proj
  ```
  proj(v1,v2,v3,v4,...,i){
    if(i==1) return(v1);
    if(i==2) return(v2);
    if(i==3) return(v3);
    if(i==4) return(v4);
    ....
  }

  ```

(b)
以下のように関数プログラムの記載が可能なため、while文を使用しない関数プログラムが存在することが証明される。

```
f(v1,v2,v3,...,vk){
  int vg1,vg2,vg3,...,vgm;
  int vh;
  vg1 = g1(v1,v2,v3,...,vk);
  vg2 = g2(v1,v2,v3,...,vk);
  vg3 = g3(v1,v2,v3,...,vk);
  ...
  vgm = gm(v1,v2,v3,...,vk);

  vh = h(vg1,vg2,vg3,...,vgm);
  return (vh);
}

```



## 5.4 

すいません、題意を理解できず。。。

# 6章

## 6.1 

```
g1(x,y) = x + y, g2(x,y) = y -.. x

x + y = 0になる最小のyかつ、y未満の値で定義域の数値が存在する、が、f1(x)で、x>0なら存在しない。
y -.. x = 0になる最小のyとすると、f2(x)=xになりそうだが、x未満の値で、g2の定義域を満たすものがない。


```

## 6.2 

```
g(p,x,y){
  inv v1;
  if(y>0){
    return(0);
  }else{
    v1 = comp(p,x); //compの定義域でないとき
    return(0);
  }

}

```

# 7 



## 7.1 

```
”決定不可能であることを示す”　＝　”定義域の場合は1を返して定義域でない場合は0を返すが　できないことを示す。”
```

compが停止するかの判定するのが不可能なため、Halt_pairは実行が終了しない場合があり、Halt_pairが決定不可能であることが示される。


## 7.2 

αを半決定可能である、の同値の条件を示す、のk変数版。

```
(1*)→(3*)
　(1*)は、Qはαを定義域とするk変数計算可能部分関数を計算するプログラムが存在する、という条件のため(3*)と同値

(3*)→(6*)
　

(6*)→(7*)
　1変数の場合と同様に(図7.4のプログラムの引数が、x1,x2)、特性関数Bがαを列挙する。
 
```

# 8

## 8.1 

## 8.2 

## 8.3 

## 8.4 

## 8.5 
