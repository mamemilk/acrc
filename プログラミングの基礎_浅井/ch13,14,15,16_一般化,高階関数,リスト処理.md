# 13章

- 多相型と、多相関数
  - 型変数で一般化していいもの(特定しない方が良いもの)は、'a, 'bで表される。読み方はα、β

    -> 強い型付けでの、多相はどうなってるかの疑問が解けた。

    -> 一方で、13.2の場合に、person_tのkeyが増えた時って、どうやって対応するんだろ。get_namae関数のパターンマッチは書き直さないとだめ？


## 問題13.1, 13.2

```ocaml
type person_t = {
  namae : string;
  m : float;
  kg : float;
  birth  : string;
  blood : string;
}

let lst = [{namae = "Mr.1"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "A";};
           {namae = "Mr.2"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "B";};
           {namae = "Mr.3"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "A";};
           {namae = "Mr.4"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "AB";};
           {namae = "Mr.5"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "O";};
           {namae = "Mr.6"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "A";};
           {namae = "Mr.7"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "B";};
           {namae = "Mr.8"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "O";}]

let rec count_ketsueki lst btype = match lst with
    [] -> 0
  | {namae = n ; m=m; kg=kg; birth=b; blood=blood;} :: rest ->
      if blood = btype then 1 + count_ketsueki rest btype
                       else count_ketsueki rest btype ;;

let testA = count_ketsueki lst "A" = 3;;
let testB = count_ketsueki lst "B" = 2;;
let testAB = count_ketsueki lst "AB" = 1;;
let testO = count_ketsueki lst "O" = 2;;
let testN = count_ketsueki lst "N" = 0;;


let get_namae person = match person with
  {namae = n ; m=m; kg=kg; birth=b; blood=blood;} -> n ;;
let person_namae lst = List.map get_namae lst;;

person_namae lst ;;

```

# 問題13.3

- 演算子を使うと型が決まってしまうので、関数のみ登場させる。
- 第一引数がどういう引数をとる関数か？というのに着目して試行錯誤してみる。

- 最後の二問はいまいち自身なし。

```ocaml

(* val a : 'a -> 'a = <fun> *)
let a f = f ;;

(* val b : 'a -> 'b -> 'a = <fun> *)
let b f g = f ;;

(* val c : 'a -> 'b -> 'b = <fun> *)
let c f g = g ;;

(* val d : 'a -> ('a -> 'b) -> 'b = <fun> *)
let d f g = (g f);;

(* val e : ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c = <fun> *)
let e f g h = g (f h);;

```

# 問題13.4

```ocaml

let compose f g = let h x = f (g x) in h;;
let test1 = (compose (fun x -> x * 2) (fun x -> x + 3)) 4 = 14;;

```

# 問題13.5

```ocaml
let twice f = let g x = f (f x) in g;;
twice twice ;;
(* ('_weak2 -> '_weak2) -> '_weak2 -> '_weak2 *)

```


# 問題13.6, 13.7


```ocaml

let koushin1 p q = let ekikan_kyori = get_ekikan_kyori p.namae q.namae global_ekikan_list in
                   if ekikan_kyori = infinity
                     then q
                     else
                       if ekikan_kyori + p.saitan_kyori >= q.saitan_kyori
                         then q
                         else {namae=q.namae; saitan_kyori=ekikan_kyori + p.saitan_kyori; temae_list=q.namae::p.temae_list}


let koushin p v = List.map (koushin1 p) v

```


# 14章

## 問題14.1

テキストでは多分まだ出てきてないが、lamdbaを使ってみる。

```ocaml

let rec even_r lst = match lst with
  [] -> []
  | first :: rest -> if first mod 2 = 0 then first :: even_r rest
                                        else even_r rest;;

let even lst = List.filter (fun x -> x mod 2 =0) lst

let test_input_list =  [2; 1; 6; 4; 7]
let test1 = even_r test_input_list = even_r test_input_list;;

```


## 問題14.2

```ocaml

type gakusei_t = {
  namae : string;
  tensuu : int;
  seiseki : string
}

let seitos = [
  {namae="1"; tensuu=90; seiseki="A";};
  {namae="2"; tensuu=80; seiseki="A";};
  {namae="3"; tensuu=70; seiseki="B";};
  {namae="4"; tensuu=60; seiseki="B";};
  {namae="5"; tensuu=60; seiseki="B";};
  {namae="6"; tensuu=30; seiseki="D";};
];;

let is_A seito = match seito with
  {namae=n; tensuu=t; seiseki=s} -> s = "A"


let count_A lst = let a_list = List.filter is_A lst in
                  List.length a_list

let test = count_A seitos = 2

```

## 問題14.3

```ocaml

let rec concat_r lst = match lst with
  [] -> ""
  | first :: rest -> first ^ concat_r rest;;

let concat lst = List.fold_right (fun a b -> a ^ b) lst ""

let test_input = ["春" ; "夏" ; "秋" ; "冬"]
let test = concat_r test_input = concat test_input ;;

```


## 問題14.4

fold_rightの型が、`bで返すので、

```ocaml
type gakusei_t = {
  namae : string;
  tensuu : int;
  seiseki : string
}

let seitos = [
  {namae="1"; tensuu=90; seiseki="A";};
  {namae="2"; tensuu=80; seiseki="A";};
  {namae="3"; tensuu=70; seiseki="B";};
  {namae="4"; tensuu=60; seiseki="B";};
  {namae="5"; tensuu=60; seiseki="B";};
  {namae="6"; tensuu=30; seiseki="D";};
];;

(* 方式1 : おそらく題意にそぐわない強引な方法？ *)
let add_seiseki a b = match a with {namae=na; tensuu=ta; seiseki=sa}
                      -> match b with {namae=nb; tensuu=tb; seiseki=sb} -> {namae=""; tensuu=ta+tb; seiseki=""}

let gakusei_sum lst = let ans = List.fold_right add_seiseki lst {namae=""; tensuu=0; seiseki=""} in
                      ans.tensuu

(* 方法2 : これが題意？ *)
let add_seiseki2 a b = match a with {namae=n; tensuu=t; seiseki=s} -> t + b

let gakusei_sum2 lst = List.fold_right add_seiseki2 lst 0;;



let test1 = gakusei_sum seitos = (90 + 80 + 70 + 60 + 60 + 30)
let test2 = gakusei_sum2 seitos = (90 + 80 + 70 + 60 + 60 + 30)

```


## 問題14.5

一つだけ局所定義にする。

```ocaml
type gakusei_t = {
  namae : string;
  tensuu : int;
  seiseki : string
}

let seitos = [
  {namae="1"; tensuu=90; seiseki="A";};
  {namae="2"; tensuu=80; seiseki="A";};
  {namae="3"; tensuu=70; seiseki="B";};
  {namae="4"; tensuu=60; seiseki="B";};
  {namae="5"; tensuu=60; seiseki="B";};
  {namae="6"; tensuu=30; seiseki="D";};
];;


let count_A lst = let is_A seito = match seito with {namae=n; tensuu=t; seiseki=s} -> s = "A" in
                  let a_list = List.filter is_A lst in
                  List.length a_list

let test = count_A seitos = 2
```


## 問題14.6

```ocaml
type person_t = {
  namae : string;
  m : float;
  kg : float;
  birth  : string;
  blood : string;
}

let lst = [{namae = "Mr.1"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "A";};
           {namae = "Mr.2"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "B";};
           {namae = "Mr.3"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "A";};
           {namae = "Mr.4"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "AB";};
           {namae = "Mr.5"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "O";};
           {namae = "Mr.6"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "A";};
           {namae = "Mr.7"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "B";};
           {namae = "Mr.8"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "O";}]

let count_ketsueki lst btype = let is_btype person = match person with {namae = n ; m=m; kg=kg; birth=b; blood=blood;} -> blood = btype in
                               let btype_lst = List.filter is_btype lst  in
                               List.length btype_lst

let testA = count_ketsueki lst "A" = 3;;
let testB = count_ketsueki lst "B" = 2;;
let testAB = count_ketsueki lst "AB" = 1;;
let testO = count_ketsueki lst "O" = 2;;
let testN = count_ketsueki lst "N" = 0;;

```


## 問題14.7

```ocaml
let koushin p v = let koushin1 p q = let ekikan_kyori = get_ekikan_kyori p.namae q.namae global_ekikan_list in
                   if ekikan_kyori = infinity
                     then q
                     else
                       if ekikan_kyori +. p.saitan_kyori >= q.saitan_kyori
                         then q
                         else {namae=q.namae; saitan_kyori=ekikan_kyori +. p.saitan_kyori; temae_list=q.namae::p.temae_list} in
                  List.map (koushin1 p) v
```


## 問題14.8

```ocaml
let test = (fun x -> x * x - 1) 4 = 15


```

## 問題14.9

```ocaml

type person_t = {
  namae : string;
  m : float;
  kg : float;
  birth  : string;
  blood : string;
}

let test = (fun p -> match p with {namae=n; m=m; kg=kg; birth=bd; blood=bl;} -> n) {namae = "Mr.1"; m = 1.67; kg = 62.0 ; birth  = "2020/1/21"; blood = "A";} = "Mr.1";;

```


## 問題14.10

```ocaml
type gakusei_t = {
  namae : string;
  tensuu : int;
  seiseki : string
}

let seitos = [
  {namae="1"; tensuu=90; seiseki="A";};
  {namae="2"; tensuu=80; seiseki="A";};
  {namae="3"; tensuu=70; seiseki="B";};
  {namae="4"; tensuu=60; seiseki="B";};
  {namae="5"; tensuu=60; seiseki="B";};
  {namae="6"; tensuu=30; seiseki="D";};
];;


let count_A lst = let a_list = List.filter (fun seito -> match seito with {namae=n; tensuu=t; seiseki=s} -> s = "A") lst in
                  List.length a_list

let test = count_A seitos = 2
```